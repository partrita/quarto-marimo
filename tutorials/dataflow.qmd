---
title: 데이터 흐름
marimo-version: 0.13.2
lang: ko
---

# marimo 노트북 실행 방식

반응형 실행은 단일 규칙을 기반으로 합니다. 셀이 실행되면 해당 셀이 정의하는 전역 변수를 참조하는 다른 모든 셀이 자동으로 실행됩니다.

반응형 실행을 제공하기 위해 marimo는 셀에서 데이터 흐름 그래프를 만듭니다.
<!---->
**팁: 자동 실행 비활성화.**

marimo를 사용하면 자동 실행을 비활성화할 수 있습니다. 노트북 설정으로 이동하여

"런타임 > 셀 변경 시"를 "지연"으로 설정합니다.

런타임이 지연되면 셀을 실행한 후 marimo는 하위 항목을 자동으로 실행하는 대신 부실로 표시합니다. 지연 런타임은 셀 실행 시기를 제어하는 동시에 노트북 상태에 대한 보장을 제공합니다.
<!---->
## 참조 및 정의

marimo 노트북은 노드가 셀을 나타내고 에지가 데이터 종속성을 나타내는 방향성 비순환 그래프입니다. marimo는 각 셀을 (실행하지 않고) 분석하여 다음을 결정함으로써 이 그래프를 만듭니다.

- 참조("refs*"), 읽지만 정의하지 않는 전역 변수
- 정의("defs"), 정의하는 전역 변수

한 셀에서 다른 셀로의 에지는 후자 셀이 전자 셀에서 정의한 전역 변수를 참조하는 경우에 존재합니다.

반응형 실행 규칙은 그래프 측면에서 다시 설명할 수 있습니다. 셀이 실행되면 해당 하위 항목이 자동으로 실행됩니다.
<!---->
### 예제

다음 네 개의 셀은 지정된 주기와 진폭을 가진 사인파를 플롯합니다. 각 셀에는 해당 참조 및 정의가 레이블로 지정되어 있습니다.

```python {.marimo hide_code="true"}
mo.accordion(
    {
        "팁: 참조 및 정의 검사": f"""
        `mo.refs()` 및 `mo.defs()`를 사용하여 지정된 셀의 참조 및 정의를 검사합니다. 이는 복잡한 노트북을 디버깅하는 데 도움이 될 수 있습니다.

        예를 들어, 이 셀의 참조 및 정의는 다음과 같습니다.

        {mo.as_html({"refs": mo.refs(), "defs": mo.defs()})}
        """
    }
)
```

```python {.marimo}
mo.md(
    f"""
    {mo.as_html(plot_wave(amplitude, period))}

    - `refs: {mo.refs()}`
    - `defs: {mo.defs()}`
    """
)
```

```python {.marimo}
period = 2 * 3.14159

mo.md(
    f"""
    - `refs: {mo.refs()}`
    - `defs: {mo.defs()}`
    """
)
```

```python {.marimo}
amplitude = 1

mo.md(
    f"""
    - `refs: {mo.refs()}`
    - `defs: {mo.defs()}`
    """
)
```

```python {.marimo}
def plot_wave(amplitude, period):
    x = np.linspace(0, 2 * np.pi, 256)
    plt.plot(x, amplitude * np.sin(2 * np.pi / period * x))
    plt.xlim(0, 2 * np.pi)
    plt.ylim(-2, 2)
    plt.xticks(
        [0, np.pi / 2, np.pi, 3 * np.pi / 2, 2 * np.pi],
        [0, r"$\pi/2$", r"$\pi$", r"$3\pi/2$", r"$2\pi$"],
    )
    plt.yticks([-2, -1, 0, 1, 2])
    plt.gcf().set_size_inches(6.5, 2.4)
    return plt.gca()

mo.md(
    f"""
    - `refs: {mo.refs()}`
    - `defs: {mo.defs()}`
    """
)
```

🌊 **시도해보세요!** 위의 셀에서 `period` 또는 `amplitude` 값을 변경한 다음 실행 버튼( ▷ )을 클릭하여 변경 사항을 등록합니다. 사인파에 어떤 일이 발생하는지 확인합니다.
<!---->
다음은 사인파 플롯을 만드는 셀과 라이브러리를 가져오는 셀에 대한 데이터 흐름 그래프입니다. 각 셀에는 해당 정의가 레이블로 지정되어 있습니다.

```
                   +------+               +-----------+
       +-----------| {mo} |-----------+   | {np, plt} |
       |           +---+--+           |   +----+------+
       |               |              |        |
       |               |              |        |
       v               v              v        v
  +----------+   +-------------+   +--+----------+
  | {period} |   | {amplitude} |   | {plot_wave} |
  +---+------+   +-----+-------+   +------+------+
      |                |                  |
      |                v                  |
      |              +----+               |
      +------------> | {} | <-------------+
                     +----+
```

아무것도 정의하지 않는 마지막 셀은 플롯을 생성합니다.
<!---->
## 데이터 흐름 프로그래밍

marimo의 런타임 규칙에는 데이터 흐름 프로그래밍에 익숙하지 않은 경우 놀랍게 보일 수 있는 몇 가지 중요한 결과가 있습니다. 아래에 이러한 결과를 나열합니다.
<!---->
### 실행 순서는 셀 순서가 아닙니다

셀이 실행되는 순서는 전적으로 데이터 흐름 그래프에 의해 결정됩니다. 이로 인해 marimo 노트북은 기존 노트북보다 더 재현 가능합니다. 또한 가져오기 또는 긴 마크다운 문자열과 같은 상용구를 편집기 하단에 배치할 수 있습니다.
<!---->
### 전역 변수 이름은 고유해야 합니다

모든 전역 변수는 하나의 셀에서만 정의할 수 있습니다. 이 제약 조건이 없으면 marimo가 셀을 실행할 순서를 알 수 없습니다.

이 제약 조건을 위반하면 marimo는 아래와 같이 유용한 오류 메시지를 제공합니다.

```python {.marimo}
planet = "Mars"
planet
```

```python {.marimo}
planet = "Earth"
planet
```

**🌊 시도해보세요!** 이전 셀에서 `planet` 이름을 `home`으로 변경한 다음 셀을 실행합니다.
<!---->
정의는 고유해야 하므로 전역 변수는 해당 변수를 만든 셀 이외의 셀에서 `+=` 또는 `-=`와 같은 연산자로 수정할 수 없습니다. 이러한 연산자는 이름 재정의로 간주됩니다.

**🌊 시도해보세요!** 다음 두 셀을 단일 셀로 병합하여 다음 오류를 제거합니다.

```python {.marimo}
count = 0
```

```python {.marimo}
count += 1
```

### 밑줄로 시작하는 변수는 셀에 로컬입니다

밑줄로 시작하는 전역 변수는 해당 변수를 정의하는 셀에 "비공개"입니다. 즉, 여러 셀에서 동일한 밑줄로 시작하는 이름을 정의할 수 있으며 한 셀의 비공개 변수는 다른 셀에서 사용할 수 없습니다.

**예제**.

```python {.marimo}
_private_variable, _ = 1, 2
_private_variable, _
```

```python {.marimo}
_private_variable, _ = 3, 4
_private_variable, _
```

```python {.marimo}
# `_private_variable` 및 `_`는 이 셀에 정의되어 있지 않습니다
_private_variable, _
```

### 셀을 삭제하면 해당 변수가 삭제됩니다

셀을 삭제하면 해당 전역 변수가 삭제된 다음 해당 변수를 참조하는 모든 셀이 실행됩니다. 이렇게 하면 편집기에서는 상태가 삭제되었지만 프로그램 메모리에서는 삭제되지 않은 경우 발생할 수 있는 심각한 버그를 방지할 수 있습니다.

```python {.marimo}
to_be_deleted = "변수가 여전히 존재합니다"

mo.md(
    """
    🌊 **시도해보세요!**

    휴지통 아이콘을 클릭하여 이 셀을 삭제합니다.
    """
)
```

```python {.marimo}
to_be_deleted
```

### 순환은 허용되지 않습니다

셀 간의 순환은 허용되지 않습니다. 예를 들어:

```python {.marimo}
one = two - 1
```

```python {.marimo}
two = one + 1
```

### marimo는 속성을 추적하지 않습니다

marimo는 전역 변수만 추적합니다. 개체 속성을 작성해도 반응형 실행이 트리거되지 않습니다.

**🌊 예제**. 다음 셀에서 `state.number` 값을 변경한 다음 셀을 실행합니다. 후속 셀이 업데이트되지 않는 것을 확인합니다.

```python {.marimo}
state.number = 1
```

```python {.marimo}
state.number
```

```python {.marimo}
class namespace:
    pass

state = namespace()
state.number = 0
```

```python {.marimo hide_code="true"}
mo.accordion(
    {
        "속성을 추적하지 않는 이유": """
        marimo는 속성을 정의하는 셀로 안정적으로 추적할 수 없습니다. 예를 들어 속성은 라이브러리 코드에서 일상적으로 생성되거나 수정됩니다.
        """
    }
)
```

### marimo는 변경 사항을 추적하지 않습니다

Python에서는 코드를 실행하지 않고 개체를 변경할지 여부를 알 수 없습니다. 따라서 목록에 추가하는 것과 같은 변경 사항은 반응형 실행을 트리거하지 않습니다.

```python {.marimo hide_code="true"}
mo.accordion(
    {
        "팁 (고급): 변경 가능한 상태": (
            """
        marimo가 속성이나 변경 사항을 추적하지 않는다는 사실을 사용하여 marimo에서 변경 가능한 상태를 구현할 수 있습니다. 이에 대한 예는 `ui` 자습서에 나와 있습니다.
        """
        )
    }
)
```

## 모범 사례

marimo가 노트북에 적용하는 제약 조건은 모두 marimo 프로그램이 방향성 비순환 그래프라는 사실의 자연스러운 결과입니다. 이 사실을 염두에 두면 marimo 방식으로 노트북을 작성하는 데 빠르게 적응할 수 있습니다.

궁극적으로 이러한 제약 조건을 통해 강력한 노트북과 앱을 만들 수 있으며 깔끔하고 재현 가능한 코드를 작성하도록 권장합니다.

marimo 방식을 유지하려면 다음 팁을 따르십시오.

```python {.marimo}
mo.accordion(tips)
```

## 다음 단계는 무엇인가요?

UI 요소 둘러보기에 대한 대화형 자습서를 확인하세요.

```
marimo tutorial ui
```

```python {.marimo}
import matplotlib.pyplot as plt
import numpy as np
```

````python {.marimo hide_code="true"}
tips = {
    "전역 변수를 드물게 사용": (
        """
        셀 간의 이름 충돌을 피하기 위해 프로그램의 전역 변수 수를 적게 유지합니다. 반응형 실행 단위가 작도록 한 셀에서 정의하는 전역 변수 수를 적게 유지합니다.
        """
    ),
    "설명적인 이름 사용": (
        """
        특히 전역 변수에 대해 설명적인 변수 이름을 사용합니다. 이렇게 하면 이름 충돌을 최소화하는 데 도움이 되며 더 나은 코드를 만들 수 있습니다.
        """
    ),
    "함수 사용": (
        """
        임시 또는 중간 변수로 전역 네임스페이스를 오염시키지 않도록 논리를 함수로 캡슐화합니다.
        """
    ),
    "변경 최소화": (
        """
        앞서 marimo가 개체 변경을 추적할 수 없다는 것을 확인했습니다. 따라서 개체를 만드는 셀에서만 개체를 변경하거나 기존 개체를 변경하는 대신 새 개체를 만듭니다.

        예를 들어 다음과 같이 하지 마십시오.

        ```python3
        # 셀
        numbers = [1, 2, 3]
        ```

        ```python3
        # 다른 셀
        numbers.append(4)
        ```

        대신 다음을 선호합니다.

        ```python3
        # 셀
        numbers = [1, 2, 3]
        numbers.append(4)
        ```

        또는

        ```python3
        # 셀
        numbers = [1, 2, 3]
        ```

        ```python3
        # 다른 셀
        more_numbers = numbers + [4]
        ```
        """
    ),
    "멱등 셀 작성": (
        """
        동일한 입력(참조)이 주어졌을 때 출력과 동작이 동일한 셀을 작성합니다. 이러한 셀을 _멱등_이라고 합니다. 이렇게 하면 버그를 피하는 데 도움이 되며 비용이 많이 드는 중간 계산을 캐시할 수 있습니다(다음 팁 참조).
        """
    ),
    "`@mo.cache`로 중간 계산 캐시": (
        """
        `mo.cache`를 사용하여 비용이 많이 드는 함수의 반환 값을 캐시합니다. 이전 팁에 따라 복잡한 논리를 멱등 함수로 추상화하면 이 작업을 수행할 수 있습니다.

        예를 들어:

        ```python3
        import marimo as mo

        @mo.cache
        def compute_prediction(problem_parameters):
          ...
        ```

        `compute_predictions`가 아직 보지 못한 `problem_parameters` 값으로 호출될 때마다 예측을 계산하고 캐시에 저장합니다. 다음에 동일한 매개변수로 호출되면 예측을 다시 계산하는 대신 캐시에서 이전에 계산된 예측을 가져옵니다.

        `functools.cache`에 익숙하다면 `mo.cache`는 비슷하지만 더 강력하며 함수를 정의하는 셀이 다시 실행되더라도 캐시가 유지됩니다.
        """
    ),
}
````

```python {.marimo}
import marimo as mo
```